output = "geeglm", testARG = NULL)
m_ar1_waves_equidist <- geem2(y ~ x, id = id, waves = time_equi,
data = exdat, corstr = "ar1",
output = "geeglm", testARG = NULL)
m_ar1_nowaves <-  geem2(y ~ x, id = id,
data = exdat, corstr = "ar1",
output = "geeglm", testARG = NULL)
m_ar1_waves_nonequidist
m_ar1_waves_equidist
m_ar1_waves_equidist
m_ar1_nowaves
formals(geem2)
formals(geem.control)
c(1, 2, 3, 4)[NULL]
#anova
anova(m)
library(geepack)
data("respiratory")
#model
m <- geem2(outcome ~ treat,
data = respiratory,
id = with(respiratory, interaction(center, id)),
family = "binomial", corstr = "exchangeable",
output = "geeglm", testARG = NULL)
mgp <- geeglm(outcome ~ treat,
data = respiratory,
id = with(respiratory, interaction(center, id)),
family = "binomial", corstr = "exchangeable")
#print
#anova
anova(m)
anova(m_ar1_nowaves)
names(respiratory)
#anova
m2 <- geem2(outcome ~ treat + sex + age + baseline,
data = respiratory,
id = with(respiratory, interaction(center, id)),
family = "binomial", corstr = "exchangeable",
output = "geeglm", testARG = NULL)
anova(m)
anova(m2)
load_all()
#anova
m2 <- geem2(outcome ~ treat + sex + age + baseline,
data = respiratory,
id = with(respiratory, interaction(center, id)),
family = "binomial", corstr = "exchangeable",
output = "geeglm")
#anova
m2 <- geem2(outcome ~ treat + sex + age + baseline,
data = respiratory,
id = with(respiratory, interaction(center, id)),
family = "binomial", corstr = "exchangeable",
output = "geeglm")
load_all()
#'                       v.names="y", times=0:4, direction="long")
#'     seiz.l <- seiz.l[order(seiz.l$id, seiz.l$time),]
#'     seiz.l$t <- ifelse(seiz.l$time == 0, 8, 2)
#'     seiz.l$x <- ifelse(seiz.l$time == 0, 0, 1)
#'
#'     seiz <- geem(y~ x + trt + x:trt+ offset(log(t)), id=id,data = seiz.l,
#'                  family = poisson, corstr = "exchangeable")
#' }
#'
#' @export
geem2 <- function(formula, id, waves=NULL, data = parent.frame(),
family = gaussian, corstr = "independence", Mv = 1,
weights = NULL, corr.mat = NULL,
nodummy = FALSE,  sandwich = TRUE,
output = "geeglm",
control = geem.control()){
########################################################################
#Check and prep input arguments ########################################
########################################################################
thiscall <- match.call()
### First, get all the relevant elements from the arguments
dat <- model.frame(formula, data, na.action = na.pass)
nn <- dim(dat)[1]
#Make id / weight / waves argument so that they can match character
#strings OR names provided in enclosing environment/data
#??? doesn't work with character strings???
if(typeof(data) != "environment") {
if(length(thiscall$id) == 1){
subj.col <- which(colnames(data) == thiscall$id)
if(length(subj.col) > 0){
id <- data[,subj.col]
} else {
id <- eval(thiscall$id, envir=parent.frame())
}
} else if(is.null(thiscall$id)) {
id <- 1:nn
}
if(length(thiscall$weights) == 1) {
weights.col <- which(colnames(data) == thiscall$weights)
if(length(weights.col) > 0) {
weights <- data[,weights.col]
} else {
weights <- eval(thiscall$weights, envir=parent.frame())
}
}
if(length(thiscall$waves) == 1) {
waves.col <- which(colnames(data) == thiscall$waves)
if(length(waves.col) > 0) {
waves <- data[,waves.col]
} else {
waves <- eval(thiscall$waves, envir=parent.frame())
}
} else if(is.null(thiscall$waves)) {
waves <- NULL
}
}
# Initialize weights if not supplied by user
if (is.null(weights)) weights <- rep(1, nn)
# Check waves argument
if (!is.null(waves) && !identical(round(waves, 0), waves)) stop("waves must be either an integer vector or NULL")
# Store objects for output
prior.weights <- weights
# Organize all dataset in dat
dat$id <- id
dat$weights <- weights
dat$waves <- waves #!!! this may be NULL => not controlled what slots are available in dat
# Sort data. If waves are available, sort accord to id and waves, otherwise
# sort only according to id
if (!is.null(waves)) {
neworder <- order(id, waves)
} else {
neworder <- order(id)
}
dat <- dat[neworder, ]
# Check if waves are equidistant. If they are, we are done using the
# values of waves now, as data have already been sorted according to waves within ids.
# If the waves are not equidistant, signal a warning and proceed as if they were
# equidistant (i.e. use only order information - this has already been done in sorting)
if (!is.null(waves)) {
waves_are_equidist <- by(dat$waves, as.factor(dat$id), is_equidistant)
if (any(!waves_are_equidist)) {
warning(paste("Non-equidistant waves were provided.",
"Note that only their ordering was used for model fitting.",
"Their numeric values were ignored."))
}
}
# Find missing information in variables used for the linear predictor and response
# note: na.inds contains information on both row and columns of NAs - both are needed below.
na.inds <- NULL
if(any(is.na(dat))){
na.inds <- which(is.na(dat), arr.ind = TRUE)
}
# Figure out the correlation structure
cor.vec <- c("independence", "ar1", "exchangeable", "m-dependent", "unstructured",
"fixed", "userdefined")
corstr <- cor.vec[charmatch(corstr, cor.vec)]
#!!!to do:
# - add step to change corstr if settings simplify (for example "m-dependent" and Mv == 1 => "ar1"?)
#!!! to do:
#!!! check what happens if length(cor.str) > 1 and check what happens if there is no match (old code below
# NOT replaced yet):
#*#  if(is.na(cor.match)){stop("Unsupported correlation structure")} #!!check if this still works
#*#
#*#   else if(cor.match == 0){
#*#         stop("Ambiguous Correlation Structure Specification")
#*#   }else{
#*#   stop("Unsupported Correlation Structure")
#*#   }
# Note that we need to assign weight 0 to rows with NAs
# in order to preserve the correlation structure
if(!is.null(na.inds)){
weights[unique(na.inds[,1])] <- 0 #!!! consider: should this be done in "weights" within dat instead?
includedvec <- weights > 0
inclsplit <- split(includedvec, id)
#Find indexes to be dropped
dropind <- NULL
# Identify ids that are missing for all observations, i.e. whole cluster must be
# missing. If so, omit it, otherwise ignore.
if(corstr %in% c("independence", "exchangeable")) {
dropind <- which(weights == 0)
} else {
allobs <- TRUE
if(any(!includedvec)){
allobs <- FALSE
uniqueid <- unique(id)
n_uniqueid <- length(uniqueid)
dodropid <- rep(FALSE, n_uniqueid)
for(i in 1:n_uniqueid) {
#Drop observation only if all obs from that individual (ID) are missing
if(all(!inclsplit[[i]])){
dodropid[i] <- TRUE
}
}
if (sum(dodropid) > 0) {
dropind <- which(id %in% uniqueid[dodropid])
}
}
}
#drop indexes just found
if(length(dropind) > 0) {
dat <- dat[-dropind,]
includedvec <- includedvec[-dropind]
weights <- weights[-dropind]
id <- id[-dropind]
}
X <- model.matrix(formula, dat) #nas
Y <- model.response(dat)
offset <- model.offset(dat)
# Intialize offset if not supplied by user
## if no offset is given, then set to zero
if (is.null(offset)) offset <- rep(0, nrow(X))
#add extra info to corstr if necessary
corstr <- list(name = corstr, extra = NULL)
if (corstr$name == "m-dependent") corstr$extra <- Mv
if (corstr$name %in% c("fixed", "userdefined")) corstr$extra <- corr.mat
# handle family argument
famret <- getfam(family)
#rename function names for standardized output family object.
# note: not sure why original geeM had different function names
# for user-supplied families. May be possible to drop this
# convention altogether
#browser()
if (!inherits(famret, "family")) {
names(famret)[c("LinkFun", "VarFun", "InvLink", "InvLinkDeriv")] <-
c("linkfun", "variance", "linkinv", "mu.eta")
}
##########################################################################################
# Do actual fitting      #################################################################
##########################################################################################
#!!! check: can we avoid passing allobs argument and instead recompute it
# in geem.fit?
results <- geem.fit(x = X, y = Y, offset = offset, weights = weights,
control = control, id = id, family = famret,
corstr = corstr, allobs = allobs, sandwich = sandwich)
##########################################################################################
# Pack and return output #################################################################
##########################################################################################
dat <- model.frame(formula, data, na.action = na.pass) #!!! check - is this different than dat defined above?
X <- model.matrix(formula, dat) #!!! check - is this different than X defined above?
if (output == "geem") {
# Create object of class geem with information about the fit
#add slots not already available in geem.fit output
results$coefnames <- colnames(X)
results$call <- thiscall
results$X <- X
results$dropped <- uniqueid[dodropid]
results$terms <- terms(formula)
results$y <- Y
results$formula <- formula
#reorder list to make it identical to previous structure
old_geem_out_order <- c("beta", "phi", "alpha", "coefnames",
"niter", "converged", "naiv.var", "var",
"call", "corr", "clusz", "FunList",
"X", "offset", "eta", "weights", "terms",
"y", "biggest.R.alpha", "formula")
results <-results[old_geem_out_order]
class(results) <- "geem"
return(results)
}
if (output == "geeglm") {
#    browser()
coefs <- results$beta
names(coefs) <- colnames(X)
# Rank of model matrix
model_rank <- Matrix::rankMatrix(na.omit(X)) #!!!!! check: ok to do na.omit here?
# construct modelinfo which is used both for geese and full geeglm object
modelInfo = list(mean.link  = famret$link,
variance = famret$family,
sca.link = "identity",
cor.link = "identity",
corstr = corstr$name,
scale.fix = scale.fix)
# construct variance objects with correct dimensions but filled with zeros
# as these alternative variance estimation options are not yet supported
# note: zero matrices in this scenario is geepack standard
vbeta <- as.matrix(results$var) #note: need "regular" matrix for geeglm methods to work
vbeta_otherse <- vbeta
vbeta_otherse[,] <- 0
vgamma_otherse <- matrix(0, nrow = length(results$phi), ncol = length(results$phi))
valpha_otherse <- matrix(0, nrow = length(results$alpha), ncol = length(results$alpha))
# construct geese object - necessary for geepack methods
geeseobj <- list(beta = coefs,
vbeta = vbeta,
vbeta.j1s = vbeta_otherse,
vbeta.fij = vbeta_otherse,
vbeta.ajs = vbeta_otherse,
vbeta.naiv = as.matrix(results$naiv.var),
gamma = results$phi, #!!! OBS: Tjek om phi og gamma er det samme eller om der er en transformation imellem
vgamma =  vgamma_otherse, #!! placeholder - check: do we compute this at all?
vgamma.j1s = vgamma_otherse,
vgamma.fij = vgamma_otherse,
vgamma.ajs = vgamma_otherse,
alpha = results$alpha, #!! placeholde - check: do we compute this at all?
valpha =  valpha_otherse,
valpha.j1s = valpha_otherse,
valpha.fij = valpha_otherse,
valpha.ajs = valpha_otherse,
model = modelInfo,
control = control,
error = NA,  #not sure what this one does
clusz = results$clusz,
zsca.names = NULL, #add printed name for dispersion parameter here
zcor.names = NULL, #add printed names for alpha parameters here
xnames = colnames(X)
)
class(geeseobj) <- c("geese", "list")
#leave out dropped observations from ordering
if (length(dropind) > 0) { #case: any obs dropped
oldorder_noNA <- order(neworder[-dropind])
} else { #case: no obs dropped
oldorder_noNA <- order(neworder)
}
out <- list(coefficients = coefs,
residuals = results$resid[oldorder_noNA],
fitted.values = results$fitted.values[oldorder_noNA],
effects = NA, #not required for glm objects, ever used? note: documented in white book
rank = model_rank, #rank of model matrix
qr = qr(na.omit(X)), #not entirely sure if this is the correct matrix to compute QR decompostion for...
#also: should we reinset dropped rows and fill them with NAs post hoc?
#also: order back to oldorder?
family = famret,
linear.predictors = results$eta[oldorder_noNA],
weights = results$weights[oldorder_noNA],
prior.weights = prior.weights,
df.residual = sum(results$weights != 0) - model_rank,
y = Y[oldorder_noNA],
model = dat,
call = thiscall,
formula = formula,
terms =  terms(formula),
data = data,
offset = results$offset[oldorder_noNA],
control = control,
method = "geem.fit",
constrasts = attr(X, "contrasts"),
xlevels = get_xlevels(dat),
geese = geeseobj,
modelInfo = modelInfo,
id = id,
corstr = corstr$name,
cor.link = "identity",
std.err = ifelse(sandwich, "sandwich", "????"))
class(out) <- c("geeglm", "gee", "glm", "lm")
return(out)
}
}
load_all()
rm(list = ls())
load_all()
library(geepack)
data("respiratory")
#model
m <- geem2(outcome ~ treat,
data = respiratory,
id = with(respiratory, interaction(center, id)),
family = "binomial", corstr = "exchangeable",
output = "geeglm", testARG = NULL)
mgp <- geeglm(outcome ~ treat,
data = respiratory,
id = with(respiratory, interaction(center, id)),
family = "binomial", corstr = "exchangeable")
#model
m <- geem2(outcome ~ treat,
data = respiratory,
id = with(respiratory, interaction(center, id)),
family = "binomial", corstr = "exchangeable",
output = "geeglm")
mgp <- geeglm(outcome ~ treat,
data = respiratory,
id = with(respiratory, interaction(center, id)),
family = "binomial", corstr = "exchangeable")
m2 <- geem2(outcome ~ treat + sex + age + baseline,
data = respiratory,
id = with(respiratory, interaction(center, id)),
family = "binomial", corstr = "exchangeable",
output = "geeglm")
mgp <- geeglm(outcome ~ treat,
data = respiratory,
id = with(respiratory, interaction(center, id)),
family = "binomial", corstr = "exchangeable")
load_all()
#model
m <- geem2(outcome ~ treat,
data = respiratory,
id = with(respiratory, interaction(center, id)),
family = "binomial", corstr = "exchangeable",
output = "geeglm")
m2 <- geem2(outcome ~ treat + sex + age + baseline,
data = respiratory,
id = with(respiratory, interaction(center, id)),
family = "binomial", corstr = "exchangeable",
output = "geeglm")
mgp <- geeglm(outcome ~ treat,
data = respiratory,
id = with(respiratory, interaction(center, id)),
family = "binomial", corstr = "exchangeable")
#print
m
#summary & summary.print
summary(m)
#predict
predict(m)
predict(m, newdata = data.frame(treat = c("A", "P")))
#confint (NEW!)
confint(m)
#QIC
QIC(m)
anova(m) #works with
anova(m2)
debugonce("geepack:::geeglm.anova")
anova(m2)
debugonce("geepack:::anova.geeglm)
#to do
####################################################################################
# Handling of non-equidistant time points via waves argument
####################################################################################
set.seed(123)
exdat <- data.frame(x = rnorm(20))
exdat$y <- exdat$x + rnorm(20)
exdat$id <- rep(1:5, each = 4)
exdat$time_nonequi <- c(1, 2, 3, 4, 1, 2, 5, 6, 1, 2, 4, 3, 5, 6, 1, 10, 1, 2, 3, 4)
exdat$time_equi <- c(1:4, 1:4,  1, 2, 4, 3,   2, 3, 1, 4,   1:4)
exdat <- exdat[sample(1:20, 20),] #scramble order
m_ar1_waves_nonequidist <- geem2(y ~ x, id = id, waves = time_nonequi,
data = exdat, corstr = "ar1",
output = "geeglm", testARG = NULL)
m_ar1_waves_equidist <- geem2(y ~ x, id = id, waves = time_equi,
data = exdat, corstr = "ar1",
output = "geeglm", testARG = NULL)
m_ar1_nowaves <-  geem2(y ~ x, id = id,
data = exdat, corstr = "ar1",
output = "geeglm", testARG = NULL)
#compare outputs
m_ar1_waves_nonequidist
m_ar1_waves_equidist
#identical results (as expected)
m_ar1_nowaves
#different results than the other
#this is also as expected, since the waves are not ordered 1:4
debugonce("geepack:::anova.geeglm")
debugonce("geepack::anova.geeglm")
geepack:::anova
geepack:::anova.geeglm
debugonce(geepack:::anova.geeglm)
anova(m2)
debugonce(geepack:::anova.geeglm)
anova(m2)
anova(m2)
debugonce(geepack:::anova.geeglm)
debugonce(geepack:::anova.geeglm)
anova(m2)
object$method
object
method(x = x[, varseq <= i, drop = FALSE],
y = object$y, weights = object$prior.weights,
corstr = object$corstr, start = object$start,
offset = object$offset, id = object$id, family = object$family,
control = object$control)
method(x = x[, varseq <= i, drop = FALSE],
y = object$y, weights = object$prior.weights,
corstr = object$corstr,
offset = object$offset, id = object$id, family = object$family,
control = object$control)
method
method(x = x[, varseq <= i, drop = FALSE],
y = object$y, weights = object$prior.weights,
corstr = object$corstr,
offset = object$offset, id = object$id, family = object$family,
control = object$control)
method(x = x[, varseq <= i, drop = FALSE],
y = object$y, weights = object$prior.weights,
corstr = object$corstr,
offset = object$offset, id = object$id, family = object$family,
control = object$control)
object$corstr
mgp2 <- geeglm(outcome ~ treat + sex + age + baseline,
data = respiratory,
id = with(respiratory, interaction(center, id)),
family = "binomial", corstr = "exchangeable")
anova(mgp2)
mglm2 <- glm(outcome ~ treat + sex + age + baseline,
data = respiratory, family = "binomial")
anova(mglm2)
names(mpg2)
names(mgp2)
mgp2$corstr
mgp2$corstr$names
mgp2$corstr$name
str(mgp2$corstr)
mgp2$start
m2$corstr
str(m2$corstr)
anova(m2)
anova(m) #works with one covariate
geepack:::anova.geeglm(m) #works with one covariate
geepack:::anova.geeglm(m2)
debugonce(geepack:::anova.geeglm)
anova(m2)
is.glm
object$prior.weights
object$start
object$corstr
method(x = x[, varseq <= i, drop = FALSE],
y = object$y, weights = object$prior.weights,
corstr = object$corstr, start = object$start,
offset = object$offset, id = object$id, family = object$family,
control = object$control)
debugonce(geepack:::anova.geeglm)
anova(mgp2)
dotargs
is.glm
varlist
debugonce(geepack:::anova.geeglm)
anova(mgp2)
method
m2$method
anova(m, m2)
