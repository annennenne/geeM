#*#   else if(cor.match == 0){
#*#         stop("Ambiguous Correlation Structure Specification")
#*#   }else{
#*#   stop("Unsupported Correlation Structure")
#*#   }
# Note that we need to assign weight 0 to rows with NAs
# in order to preserve the correlation structure
if(!is.null(na.inds)){
weights[unique(na.inds[,1])] <- 0 #!!! consider: should this be done in "weights" within dat instead?
}
includedvec <- weights > 0
inclsplit <- split(includedvec, id)
#Find indexes to be dropped
dropind <- NULL
# Identify ids that are missing for all observations, i.e. whole cluster must be
# missing. If so, omit it, otherwise ignore.
if(corstr %in% c("independence", "exchangeable")) {
dropind <- which(weights == 0)
} else {
allobs <- TRUE
if(any(!includedvec)){
allobs <- FALSE
uniqueid <- unique(id)
n_uniqueid <- length(uniqueid)
dodropid <- rep(FALSE, n_uniqueid)
for(i in 1:n_uniqueid) {
#Drop observation only if all obs from that individual (ID) are missing
if(all(!inclsplit[[i]])){
dodropid[i] <- TRUE
}
}
if (sum(dodropid) > 0) {
dropind <- which(id %in% uniqueid[dodropid])
}
}
}
#drop indexes just found
if(length(dropind) > 0) {
dat <- dat[-dropind,]
includedvec <- includedvec[-dropind]
weights <- weights[-dropind]
id <- id[-dropind]
}
X <- model.matrix(formula, dat) #nas
Y <- model.response(dat)
offset <- model.offset(dat)
# Intialize offset if not supplied by user
## if no offset is given, then set to zero
if (is.null(offset)) offset <- rep(0, nrow(X))
# add extra info to corstr if necessary. These are stored as attributes.
if (corstr == "m-dependent") {
attr(corstr, "Mv") <- Mv
} else if (corstr %in% c("fixed", "userdefined")) {
attr(corstr, "cprr.mat") <- corr.mat
}
# handle family argument
famret <- getfam(family)
#rename function names for standardized output family object.
# note: not sure why original geeM had different function names
# for user-supplied families. May be possible to drop this
# convention altogether
#browser()
if (!inherits(famret, "family")) {
names(famret)[c("LinkFun", "VarFun", "InvLink", "InvLinkDeriv")] <-
c("linkfun", "variance", "linkinv", "mu.eta")
}
##########################################################################################
# Do actual fitting      #################################################################
##########################################################################################
#!!! check: can we avoid passing allobs argument and instead recompute it
# in geem.fit?
results <- geem.fit(x = X, y = Y, offset = offset, weights = weights,
control = control, id = id, family = famret,
corstr = corstr, allobs = allobs)
##########################################################################################
# Pack and return output #################################################################
##########################################################################################
#####!!!!!!!!!! MOVE THIS BACK INTO IF GEEM!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# new dat and X objects are standard in geem - these will be ordered as
# the original input data but may differ in observations if NAs were dropped
# along the way!
newdat <- model.frame(formula, data, na.action = na.pass)
results$X <- model.matrix(formula, newdat)
#  browser()
if (output == "geem") {
# Create object of class geem with information about the fit
#add slots not already available in geem.fit output
results$coefnames <- colnames(X)
results$call <- thiscall
results$X <- X
results$dropped <- uniqueid[dodropid]
results$terms <- terms(formula)
results$y <- Y
results$formula <- formula
results$var <- results$vbeta
#reorder list to make it identical to previous structure
old_geem_out_order <- c("beta", "phi", "alpha", "coefnames",
"niter", "converged", "naiv.var", "var",
"call", "corr", "clusz", "FunList",
"X", "offset", "eta", "weights", "terms",
"y", "biggest.R.alpha", "formula")
results <-results[old_geem_out_order]
class(results) <- "geem"
return(results)
}
if (output == "geeglm") {
#    browser()
coefs <- results$beta
names(coefs) <- colnames(X)
# Rank of model matrix
model_rank <- Matrix::rankMatrix(na.omit(X)) #!!!!! check: ok to do na.omit here?
# construct modelinfo which is used both for geese and full geeglm object
modelInfo = list(mean.link  = famret$link,
variance = famret$family,
sca.link = "identity",
cor.link = "identity",
corstr = corstr,
scale.fix = control$scale.fix)
# construct variance objects with correct dimensions but filled with zeros
# as these alternative variance estimation options are not yet supported
# note: zero matrices in this scenario is geepack standard
vbeta <- results$vbeta #note: need "regular" matrix for geeglm methods to work
vbeta_otherse <- vbeta
vbeta_otherse[,] <- 0
vgamma_otherse <- matrix(0, nrow = length(results$phi), ncol = length(results$phi))
valpha_otherse <- matrix(0, nrow = length(results$alpha), ncol = length(results$alpha))
# construct geese object - necessary for geepack methods
geeseobj <- list(beta = coefs,
vbeta = vbeta,
vbeta.j1s = vbeta_otherse,
vbeta.fij = vbeta_otherse,
vbeta.ajs = vbeta_otherse,
vbeta.naiv = as.matrix(results$naiv.var),
gamma = results$phi, #!!! OBS: Tjek om phi og gamma er det samme eller om der er en transformation imellem
vgamma =  vgamma_otherse, #!! placeholder - check: do we compute this at all?
vgamma.j1s = vgamma_otherse,
vgamma.fij = vgamma_otherse,
vgamma.ajs = vgamma_otherse,
alpha = results$alpha, #!! placeholde - check: do we compute this at all?
valpha =  valpha_otherse,
valpha.j1s = valpha_otherse,
valpha.fij = valpha_otherse,
valpha.ajs = valpha_otherse,
model = modelInfo,
control = control,
error = NA,  #not sure what this one does
clusz = results$clusz,
zsca.names = NULL, #add printed name for dispersion parameter here
zcor.names = NULL, #add printed names for alpha parameters here
xnames = colnames(X)
)
class(geeseobj) <- c("geese", "list")
#leave out dropped observations from ordering
if (length(dropind) > 0) { #case: any obs dropped
oldorder_noNA <- order(neworder[-dropind])
} else { #case: no obs dropped
oldorder_noNA <- order(neworder)
}
out <- list(coefficients = coefs,
residuals = results$resid[oldorder_noNA],
fitted.values = results$fitted.values[oldorder_noNA],
effects = NA, #not required for glm objects, ever used? note: documented in white book
rank = model_rank, #rank of model matrix
qr = qr(na.omit(X)), #not entirely sure if this is the correct matrix to compute QR decompostion for...
#also: should we reinset dropped rows and fill them with NAs post hoc?
#also: order back to oldorder?
family = famret,
linear.predictors = results$eta[oldorder_noNA],
weights = results$weights[oldorder_noNA],
prior.weights = prior.weights,
df.residual = sum(results$weights != 0) - model_rank,
y = Y[oldorder_noNA],
model = dat[, setdiff(names(dat), c("id", "weights"))],##!!!!!!!!!!!!should be dat???? # note: this should NOT be reordered/recomputed. It is used by anova/drop1/add1 to fit new
# models on the same exact observations.
call = thiscall,
formula = formula,
terms =  terms(formula),
data = data,
offset = results$offset[oldorder_noNA],
control = control,
method = "geem.fit",
constrasts = attr(X, "contrasts"),
xlevels = get_xlevels(dat),
geese = geeseobj,
modelInfo = modelInfo,
id = id,
corstr = corstr,
cor.link = "identity",
std.err = control$std.err,
oldat = newdat) #DELETE!!!!!
class(out) <- c("geeglm", "gee", "glm", "lm")
return(out)
}
}
load_all()
rm(list = "geem2")
load_all()
m2_b <- geem2(outcome ~ treat + sex , # + baseline,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
anova(m2_b)
head(respiratory)
head(respiratory[order(respiratory$useid),], 20)
debugonce(geepack:::anova.geeglm)
m2_b <- geem2(outcome ~ treat + sex , # + baseline,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
anova(m2_b)
betaList
betaList
table
beta
betaList
debugonce(geepack:::anova.geeglm)
anova(mgp2_b)
fit
fit$beta
betaList
0.7317     -0.9802      0.0278
0.7317     -0.9802      0.0278
m
load_all()
m <- geem2(outcome ~ treat,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
m
m2_b <- geem2(outcome ~ treat + sex , # + baseline,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
anova(m2_b)
#comaparison of two nested models - doesn't work
anova(m, m2) #doesn't work!
#model
m0 <- geem2(outcome ~ 1,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
m <- geem2(outcome ~ treat,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
m2 <- geem2(outcome ~ treat + sex + age + baseline,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
mgp0 <- geeglm(outcome ~ 1,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable")
mgp <- geeglm(outcome ~ treat,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable")
mgp2 <- geeglm(outcome ~ treat + sex + age + baseline,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable")
#comaparison of two nested models - doesn't work
anova(m, m2) #doesn't work!
anova(mgp, mgp2)
anova(mglm0, mglm2)
#comaparison of two nested models - doesn't work
anova(m, m2) #doesn't work!
debugonce(geepack:::anova.geeglm)
#comaparison of two nested models - doesn't work
anova(m, m2) #doesn't work!
m1
m2
debugonce(geepack:::anovageePrim2)
debugonce(geepack:::anovageePrim2)
#comaparison of two nested models - doesn't work
anova(m, m2) #doesn't work!
m1
m2
mm1
head(mm1)
head(mm2)
head(mm1, 20)
head(mm2, 20)
P1
P2
e2
e1
mf1
mf2
nymm1
head(nymm1)
head(nymm1)
m1call
head(nymm1)
m1call
eval(m1call)
m1call$offset
?geeglm
geem.control
?glm
lm(outcome ~ treat + offset(baseline) + offset(1), respiratory)
lm(outcome ~ treat + offset(baseline) + offset(rep(1, nrow(respiratory))), respiratory)
lm(outcome ~ treat + offset(baseline) + offset(rep(1, nrow(respiratory))), respiratory)$model
model.offset(lm(outcome ~ treat + offset(baseline) + offset(rep(1, nrow(respiratory))), respiratory)$model)
model.offset(lm(outcome ~ treat + offset(baseline) + offset(rep(1, nrow(respiratory))), respiratory)$model) == respiratory$baseline + 1
load_all()
anova(mgp, mgp2)
#comaparison of two nested models - doesn't work
anova(m, m2) #doesn't work!
debugonce(geem.fit)
#comaparison of two nested models - doesn't work
anova(m, m2) #doesn't work!
head(x)
head(y)
head(id)
head(offset)
load_all()
anova(mgp, mgp2)
#comaparison of two nested models - doesn't work
anova(m, m2) #doesn't work!
m <- geem2(outcome ~ treat,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
m2 <- geem2(outcome ~ treat + sex + age + baseline,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
#comaparison of two nested models - doesn't work
anova(m, m2) #doesn't work!
#comaparison of two nested models - doesn't work
anova(m, m2) #doesn't work!
beta
control
interceptcol <- apply(x == 1, 2, all)
interceptcol
load_all()
m2 <- geem2(outcome ~ treat + sex + age + baseline,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
m_glm
mglm$coef
m_glm$coefficients
load_all()
m <- geem2(outcome ~ treat,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
m
gp
mgp
load_all()
#model
m0 <- geem2(outcome ~ 1,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
m <- geem2(outcome ~ treat,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
m2 <- geem2(outcome ~ treat + sex + age + baseline,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
mgp0 <- geeglm(outcome ~ 1,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable")
mgp <- geeglm(outcome ~ treat,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable")
mgp2 <- geeglm(outcome ~ treat + sex + age + baseline,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable")
m0; mgp0
m; mgp
mgp2; m2
m0 <- geem2(outcome ~ 1,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
m <- geem2(outcome ~ treat,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
m2 <- geem2(outcome ~ treat + sex + age + baseline,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
mgp0 <- geeglm(outcome ~ 1,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable")
mgp <- geeglm(outcome ~ treat,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable")
mgp2 <- geeglm(outcome ~ treat + sex + age + baseline,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable")
#comaparison of two nested models - doesn't work
anova(m, m2) #doesn't work!
anova(mgp, mgp2)
anova(mglm0, mglm2)
drop1
library(MESS)
install.package("MESS")
install.packages("MESS")
library(MESS)
drop1(mgp)
drop1(m2)
drop(mgp2)
drop1(mgp2)
add1(mgp2)
?add1
add1(mgp, ~ sex + baseline)
add1(mgp, . ~ sex + baseline)
add1(mgp)
#drop1/add1
MESS::drop1(m2)
#drop1/add1
MESS:::drop1(m2)
drop1(m2)
add1(m0, ~ treat)
add1.geeglm(m0, ~ treat)
MESS:::add1.geeglm(m0, ~ treat)
library(lme4)
?getME
getME()
get
?get
getSlots
get
?getME
foo <- function(list, slotname) {
list[[slotname]]
}
library(geepack)
data("respiratory")
respiratory$useid <- with(respiratory, interaction(center, id))
#model
m0 <- geem2(outcome ~ 1,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
m <- geem2(outcome ~ treat,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
m2 <- geem2(outcome ~ treat + sex + age + baseline,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
library(geepack)
library(devtools)
load_all()
source("devnotes/helpers.R")
library(geepack)
data("respiratory")
respiratory$useid <- with(respiratory, interaction(center, id))
#model
m0 <- geem2(outcome ~ 1,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
m <- geem2(outcome ~ treat,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
m2 <- geem2(outcome ~ treat + sex + age + baseline,
data = respiratory,
id = useid,
family = "binomial", corstr = "exchangeable",
output = "geeglm")
foo(m2, "coefficients")
names(m2)
m2$family
str(m2$family)
?family
m2$rank
m2$beta
m2$coefficients
?geese
names(m2$geese)
m2$geese$clusz
